        -:    0:Source:../common/FunctionPointer.h
        -:    0:Graph:objs/m2mconnectionhandlerimpl_mbed_unit/m2mconnectionhandlerpimpl.gcno
        -:    0:Data:objs/m2mconnectionhandlerimpl_mbed_unit/m2mconnectionhandlerpimpl.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* mbed Microcontroller Library
        -:    2: * Copyright (c) 2006-2015 ARM Limited
        -:    3: *
        -:    4: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    5: * you may not use this file except in compliance with the License.
        -:    6: * You may obtain a copy of the License at
        -:    7: *
        -:    8: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    9: *
        -:   10: * Unless required by applicable law or agreed to in writing, software
        -:   11: * distributed under the License is distributed on an "AS IS" BASIS,
        -:   12: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   13: * See the License for the specific language governing permissions and
        -:   14: * limitations under the License.
        -:   15: */
        -:   16:#ifndef MBED_FUNCTIONPOINTER_H
        -:   17:#define MBED_FUNCTIONPOINTER_H
        -:   18:
        -:   19:#include <string.h>
        -:   20:#include <stdint.h>
        -:   21:#include <stddef.h>
        -:   22:#include <stdarg.h>
        -:   23:#include <new>
        -:   24:#include "FunctionPointerBase.h"
        -:   25:#include "FunctionPointerBind.h"
        -:   26:
        -:   27:namespace mbed {
        -:   28:/** A class for storing and calling a pointer to a static or member void function without arguments
        -:   29: */
        -:   30:template <typename R>
        -:   31:class FunctionPointer0 : public FunctionPointerBase<R>{
        -:   32:public:
        -:   33:    typedef R(*static_fp)(void);
        -:   34:    typedef struct arg_struct{
        -:   35:    } ArgStruct;
        -:   36:    /** Create a FunctionPointer, attaching a static function
        -:   37:     *
        -:   38:     *  @param function The void static function to attach (default is none)
        -:   39:     */
        -:   40:    FunctionPointer0(static_fp function = 0):
        -:   41:        FunctionPointerBase<R>()
        -:   42:    {
        -:   43:        attach(function);
        -:   44:    }
        -:   45:
        -:   46:    /** Create a FunctionPointer, attaching a member function
        -:   47:     *
        -:   48:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:   49:     *  @param function The address of the void member function to attach
        -:   50:     */
        -:   51:    template<typename T>
        -:   52:    FunctionPointer0(T *object, R (T::*member)(void)):
        -:   53:        FunctionPointerBase<R>()
        -:   54:    {
        -:   55:        attach(object, member);
        -:   56:    }
        -:   57:
        -:   58:    /** Attach a static function
        -:   59:     *
        -:   60:     *  @param function The void static function to attach (default is none)
        -:   61:     */
        -:   62:    void attach(static_fp function) {
        -:   63:        FunctionPointerBase<R>::_object = reinterpret_cast<void*>(function);
        -:   64:        FunctionPointerBase<R>::_membercaller = &FunctionPointer0::staticcaller;
        -:   65:    }
        -:   66:
        -:   67:    /** Attach a member function
        -:   68:     *
        -:   69:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:   70:     *  @param function The address of the void member function to attach
        -:   71:     */
        -:   72:    template<typename T>
        -:   73:    void attach(T *object, R (T::*member)(void)) {
        -:   74:        FunctionPointerBase<R>::_object = static_cast<void*>(object);
        -:   75:        *reinterpret_cast<R (T::**)(void)>(FunctionPointerBase<R>::_member) = member;
        -:   76:        FunctionPointerBase<R>::_membercaller = &FunctionPointer0::membercaller<T>;
        -:   77:    }
        -:   78:
        -:   79:    /** Call the attached static or member function
        -:   80:     */
        -:   81:    R call(){
        -:   82:        return FunctionPointerBase<R>::call(NULL);
        -:   83:    }
        -:   84:
        -:   85:    FunctionPointerBind<R> bind() {
        -:   86:        FunctionPointerBind<R> fp;
        -:   87:        fp.bind(&FunctionPointerBase<R>::_nullops, (ArgStruct *) NULL, this);
        -:   88:        return fp;
        -:   89:    }
        -:   90:
        -:   91:    static_fp get_function()const {
        -:   92:        return reinterpret_cast<static_fp>(FunctionPointerBase<R>::_object);
        -:   93:    }
        -:   94:
        -:   95:    R operator ()(void) {
        -:   96:        return call();
        -:   97:    }
        -:   98:
        -:   99:private:
        -:  100:    template<typename T>
        -:  101:    static R membercaller(void *object, uintptr_t *member, void *arg) {
        -:  102:        (void) arg;
        -:  103:        T* o = static_cast<T*>(object);
        -:  104:        R (T::**m)(void) = reinterpret_cast<R (T::**)(void)>(member);
        -:  105:        return (o->**m)();
        -:  106:    }
        -:  107:    static R staticcaller(void *object, uintptr_t *member, void *arg) {
        -:  108:        (void) arg;
        -:  109:        (void) member;
        -:  110:        static_fp f = reinterpret_cast<static_fp>(object);
        -:  111:        return f();
        -:  112:    }
        -:  113:};
        -:  114:
        -:  115:/* If we had variaditic templates, this wouldn't be a problem, but until C++11 is enabled, we are stuck with multiple classes... */
        -:  116:
        -:  117:/** A class for storing and calling a pointer to a static or member void function with one argument
        -:  118: */
        -:  119:template <typename R, typename A1>
    #####:  120:class FunctionPointer1 : public FunctionPointerBase<R> {
        -:  121:protected:
        -:  122:    typedef struct arg_struct{
        -:  123:        A1 a1;
        -:  124:        arg_struct(const A1 *b1) {
        -:  125:            a1 = *b1;
        -:  126:        }
        -:  127:    } ArgStruct;
        -:  128:
        -:  129:public:
        -:  130:    typedef R(*static_fp)(A1);
        -:  131:    /** Create a FunctionPointer, attaching a static function
        -:  132:     *
        -:  133:     *  @param function The void static function to attach (default is none)
        -:  134:     */
    #####:  135:    FunctionPointer1(static_fp function = 0) {
    #####:  136:        attach(function);
    #####:  137:    }
        -:  138:
        -:  139:    /** Create a FunctionPointer, attaching a member function
        -:  140:     *
        -:  141:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:  142:     *  @param function The address of the void member function to attach
        -:  143:     */
        -:  144:    template<typename T>
        3:  145:    FunctionPointer1(T *object, R (T::*member)(A1)) {
        3:  146:        attach(object, member);
        3:  147:    }
        -:  148:
        -:  149:    /** Attach a static function
        -:  150:     *
        -:  151:     *  @param function The void static function to attach (default is none)
        -:  152:     */
    #####:  153:    void attach(static_fp function) {
    #####:  154:        FunctionPointerBase<R>::_object = reinterpret_cast<void*>(function);
    #####:  155:        FunctionPointerBase<R>::_membercaller = &FunctionPointer1::staticcaller;
    #####:  156:    }
        -:  157:
        -:  158:    /** Attach a member function
        -:  159:     *
        -:  160:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:  161:     *  @param function The address of the void member function to attach
        -:  162:     */
        -:  163:    template<typename T>
        3:  164:    void attach(T *object, R (T::*member)(A1))
        -:  165:    {
        3:  166:        FunctionPointerBase<R>::_object = static_cast<void*>(object);
        3:  167:        *reinterpret_cast<R (T::**)(A1)>(FunctionPointerBase<R>::_member) = member;
        3:  168:        FunctionPointerBase<R>::_membercaller = &FunctionPointer1::membercaller<T>;
        3:  169:    }
        -:  170:
        -:  171:    FunctionPointerBind<R> bind(const A1 &a1) {
        -:  172:        FunctionPointerBind<R> fp;
        -:  173:        fp.bind(&_fp1_ops, (ArgStruct *) NULL, this, &a1);
        -:  174:        return fp;
        -:  175:    }
        -:  176:
        -:  177:
        -:  178:    /** Call the attached static or member function
        -:  179:     */
        -:  180:    R call(A1 a1)
        -:  181:    {
        -:  182:        ArgStruct Args(&a1);
        -:  183:        return FunctionPointerBase<R>::call(&Args);
        -:  184:    }
        -:  185:
        -:  186:    static_fp get_function()const
        -:  187:    {
        -:  188:        return reinterpret_cast<static_fp>(FunctionPointerBase<R>::_object);
        -:  189:    }
        -:  190:
        -:  191:    R operator ()(A1 a) {
        -:  192:        return call(a);
        -:  193:    }
        -:  194:
        -:  195:private:
        -:  196:    template<typename T>
    #####:  197:    static R membercaller(void *object, uintptr_t *member, void *arg) {
    #####:  198:        ArgStruct *Args = static_cast<ArgStruct *>(arg);
    #####:  199:        T* o = static_cast<T*>(object);
    #####:  200:        R (T::**m)(A1) = reinterpret_cast<R (T::**)(A1)>(member);
    #####:  201:        return (o->**m)(Args->a1);
        -:  202:    }
    #####:  203:    static R staticcaller(void *object, uintptr_t *member, void *arg) {
    #####:  204:        ArgStruct *Args = static_cast<ArgStruct *>(arg);
        -:  205:        (void) member;
    #####:  206:        static_fp f = reinterpret_cast<static_fp>(object);
    #####:  207:        return f(Args->a1);
        -:  208:    }
        -:  209:/*    static void constructor(void * dest, va_list args) {
        -:  210:        new(dest) ArgStruct(va_arg(args,A1*));
        -:  211:    }
        -:  212:    static void copy_constructor(void *dest , void* src) {
        -:  213:        ArgStruct *src_args = static_cast<ArgStruct *>(src);
        -:  214:        new(dest) ArgStruct(&(src_args->a1));
        -:  215:    }
        -:  216:    static void destructor(void *args) {
        -:  217:        ArgStruct *argstruct = static_cast<ArgStruct *>(args);
        -:  218:        argstruct->~arg_struct();
        -:  219:    }
        -:  220:*/
        -:  221:protected:
        -:  222:    static const struct FunctionPointerBase<R>::ArgOps _fp1_ops;
        -:  223:};
        -:  224:
        -:  225:template <typename R, typename A1>
        -:  226:const struct FunctionPointerBase<R>::ArgOps FunctionPointer1<R,A1>::_fp1_ops = {
        -:  227:    FunctionPointer1<R,A1>::constructor,
        -:  228:    FunctionPointer1<R,A1>::copy_constructor,
        -:  229:    FunctionPointer1<R,A1>::destructor
        -:  230:};
        -:  231:
        -:  232:
        -:  233:/** A class for storing and calling a pointer to a static or member void function with two arguments
        -:  234: */
        -:  235:template <typename R, typename A1, typename A2>
    #####:  236:class FunctionPointer2 : public FunctionPointerBase<R> {
        -:  237:protected:
        -:  238:    typedef struct arg_struct{
        -:  239:        A1 a1;
        -:  240:        A2 a2;
        -:  241:        arg_struct(const A1 *b1, const A2 *b2) {
        -:  242:            a1 = *b1;
        -:  243:            a2 = *b2;
        -:  244:        }
        -:  245:    } ArgStruct;
        -:  246:
        -:  247:public:
        -:  248:    typedef R(*static_fp)(A1, A2);
        -:  249:    /** Create a FunctionPointer, attaching a static function
        -:  250:     *
        -:  251:     *  @param function The void static function to attach (default is none)
        -:  252:     */
        -:  253:    FunctionPointer2(static_fp function = 0) {
        -:  254:        attach(function);
        -:  255:    }
        -:  256:
        -:  257:    /** Create a FunctionPointer, attaching a member function
        -:  258:     *
        -:  259:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:  260:     *  @param function The address of the void member function to attach
        -:  261:     */
        -:  262:    template<typename T>
       42:  263:    FunctionPointer2(T *object, R (T::*member)(A1, A2)) {
       42:  264:        attach(object, member);
       42:  265:    }
        -:  266:
        -:  267:    /** Attach a static function
        -:  268:     *
        -:  269:     *  @param function The void static function to attach (default is none)
        -:  270:     */
        -:  271:    void attach(static_fp function) {
        -:  272:        FunctionPointerBase<R>::_object = reinterpret_cast<void*>(function);
        -:  273:        FunctionPointerBase<R>::_membercaller = &FunctionPointer2::staticcaller;
        -:  274:    }
        -:  275:
        -:  276:    /** Attach a member function
        -:  277:     *
        -:  278:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:  279:     *  @param function The address of the void member function to attach
        -:  280:     */
        -:  281:    template<typename T>
       42:  282:    void attach(T *object, R (T::*member)(A1, A2))
        -:  283:    {
       42:  284:        FunctionPointerBase<R>::_object = static_cast<void*>(object);
       42:  285:        *reinterpret_cast<R (T::**)(A1, A2)>(FunctionPointerBase<R>::_member) = member;
       42:  286:        FunctionPointerBase<R>::_membercaller = &FunctionPointer2::membercaller<T>;
       42:  287:    }
        -:  288:
        -:  289:    FunctionPointerBind<R> bind(const A1 &a1, const A2 &a2) {
        -:  290:        FunctionPointerBind<R> fp;
        -:  291:        fp.bind(&_fp2_ops, (ArgStruct *) NULL, this, &a1, &a2);
        -:  292:        return fp;
        -:  293:    }
        -:  294:
        -:  295:
        -:  296:    /** Call the attached static or member function
        -:  297:     */
        -:  298:    R call(A1 a1, A2 a2)
        -:  299:    {
        -:  300:        ArgStruct Args(&a1, &a2);
        -:  301:        return FunctionPointerBase<R>::call(&Args);
        -:  302:    }
        -:  303:
        -:  304:    static_fp get_function()const
        -:  305:    {
        -:  306:        return reinterpret_cast<static_fp>(FunctionPointerBase<R>::_object);
        -:  307:    }
        -:  308:
        -:  309:    R operator ()(A1 a1, A2 a2) {
        -:  310:        return call(a1, a2);
        -:  311:    }
        -:  312:
        -:  313:private:
        -:  314:    template<typename T>
    #####:  315:    static R membercaller(void *object, uintptr_t *member, void *arg) {
    #####:  316:        ArgStruct *Args = static_cast<ArgStruct *>(arg);
    #####:  317:        T* o = static_cast<T*>(object);
    #####:  318:        R (T::**m)(A1, A2) = reinterpret_cast<R (T::**)(A1, A2)>(member);
    #####:  319:        return (o->**m)(Args->a1, Args->a2);
        -:  320:    }
        -:  321:    static R staticcaller(void *object, uintptr_t *member, void *arg) {
        -:  322:        ArgStruct *Args = static_cast<ArgStruct *>(arg);
        -:  323:        (void) member;
        -:  324:        static_fp f = reinterpret_cast<static_fp>(object);
        -:  325:        return f(Args->a1, Args->a2);
        -:  326:    }
        -:  327:/*    static void constructor(void * dest, va_list args) {
        -:  328:        A1 *a1 = va_arg(args, A1*);
        -:  329:        A2 *a2 = va_arg(args, A2*);
        -:  330:        new(dest) ArgStruct(a1, a2);
        -:  331:    }
        -:  332:    static void copy_constructor(void *dest , void* src) {
        -:  333:        ArgStruct *src_args = static_cast<ArgStruct *>(src);
        -:  334:        new(dest) ArgStruct(&(src_args->a1), &(src_args->a2));
        -:  335:    }
        -:  336:    static void destructor(void *args) {
        -:  337:        ArgStruct *argstruct = static_cast<ArgStruct *>(args);
        -:  338:        argstruct->~arg_struct();
        -:  339:    }
        -:  340:*/
        -:  341:protected:
        -:  342:    static const struct FunctionPointerBase<R>::ArgOps _fp2_ops;
        -:  343:};
        -:  344:
        -:  345:template <typename R, typename A1, typename A2>
        -:  346:const struct FunctionPointerBase<R>::ArgOps FunctionPointer2<R,A1,A2>::_fp2_ops = {
        -:  347:    FunctionPointer2<R,A1,A2>::constructor,
        -:  348:    FunctionPointer2<R,A1,A2>::copy_constructor,
        -:  349:    FunctionPointer2<R,A1,A2>::destructor
        -:  350:};
        -:  351:
        -:  352:/** A class for storing and calling a pointer to a static or member void function with three arguments
        -:  353: */
        -:  354:template <typename R, typename A1, typename A2, typename A3>
    #####:  355:class FunctionPointer3 : public FunctionPointerBase<R> {
        -:  356:protected:
        -:  357:    typedef struct arg_struct{
        -:  358:        A1 a1;
        -:  359:        A2 a2;
        -:  360:        A3 a3;
        -:  361:        arg_struct(const A1 *b1, const A2 *b2, const A3* b3) {
        -:  362:            a1 = *b1;
        -:  363:            a2 = *b2;
        -:  364:            a3 = *b3;
        -:  365:        }
        -:  366:    } ArgStruct;
        -:  367:
        -:  368:public:
        -:  369:    typedef R(*static_fp)(A1, A2, A3);
        -:  370:    /** Create a FunctionPointer, attaching a static function
        -:  371:     *
        -:  372:     *  @param function The void static function to attach (default is none)
        -:  373:     */
        -:  374:    FunctionPointer3(static_fp function = 0) {
        -:  375:        attach(function);
        -:  376:    }
        -:  377:
        -:  378:    /** Create a FunctionPointer, attaching a member function
        -:  379:     *
        -:  380:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:  381:     *  @param function The address of the void member function to attach
        -:  382:     */
        -:  383:    template<typename T>
        1:  384:    FunctionPointer3(T *object, R (T::*member)(A1, A2, A3)) {
        1:  385:        attach(object, member);
        1:  386:    }
        -:  387:
        -:  388:    /** Attach a static function
        -:  389:     *
        -:  390:     *  @param function The void static function to attach (default is none)
        -:  391:     */
        -:  392:    void attach(static_fp function) {
        -:  393:        FunctionPointerBase<R>::_object = reinterpret_cast<void*>(function);
        -:  394:        FunctionPointerBase<R>::_membercaller = &FunctionPointer3::staticcaller;
        -:  395:    }
        -:  396:
        -:  397:    /** Attach a member function
        -:  398:     *
        -:  399:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:  400:     *  @param function The address of the void member function to attach
        -:  401:     */
        -:  402:    template<typename T>
        1:  403:    void attach(T *object, R (T::*member)(A1, A2, A3))
        -:  404:    {
        1:  405:        FunctionPointerBase<R>::_object = static_cast<void*>(object);
        1:  406:        *reinterpret_cast<R (T::**)(A1, A2, A3)>(FunctionPointerBase<R>::_member) = member;
        1:  407:        FunctionPointerBase<R>::_membercaller = &FunctionPointer3::membercaller<T>;
        1:  408:    }
        -:  409:
        -:  410:    FunctionPointerBind<R> bind(const A1 &a1, const A2 &a2, const A3 &a3) {
        -:  411:        FunctionPointerBind<R> fp;
        -:  412:        fp.bind(&_fp3_ops, (ArgStruct *) NULL, this, &a1, &a2, &a3);
        -:  413:        return fp;
        -:  414:    }
        -:  415:
        -:  416:
        -:  417:    /** Call the attached static or member function
        -:  418:     */
        -:  419:    R call(A1 a1, A2 a2, A3 a3)
        -:  420:    {
        -:  421:        ArgStruct Args(&a1, &a2, &a3);
        -:  422:        return FunctionPointerBase<R>::call(&Args);
        -:  423:    }
        -:  424:
        -:  425:    static_fp get_function()const
        -:  426:    {
        -:  427:        return reinterpret_cast<static_fp>(FunctionPointerBase<R>::_object);
        -:  428:    }
        -:  429:
        -:  430:    R operator ()(A1 a1, A2 a2, A3 a3) {
        -:  431:        return call(a1, a2, a3);
        -:  432:    }
        -:  433:
        -:  434:private:
        -:  435:    template<typename T>
    #####:  436:    static R membercaller(void *object, uintptr_t *member, void *arg) {
    #####:  437:        ArgStruct *Args = static_cast<ArgStruct *>(arg);
    #####:  438:        T* o = static_cast<T*>(object);
    #####:  439:        R (T::**m)(A1, A2, A3) = reinterpret_cast<R (T::**)(A1, A2, A3)>(member);
    #####:  440:        return (o->**m)(Args->a1, Args->a2, Args->a3);
        -:  441:    }
        -:  442:    static R staticcaller(void *object, uintptr_t *member, void *arg) {
        -:  443:        ArgStruct *Args = static_cast<ArgStruct *>(arg);
        -:  444:        (void) member;
        -:  445:        static_fp f = reinterpret_cast<static_fp>(object);
        -:  446:        return f(Args->a1, Args->a2, Args->a3);
        -:  447:    }
        -:  448:/*    static void constructor(void * dest, va_list args) {
        -:  449:        A1 *a1 = va_arg(args, A1*);
        -:  450:        A2 *a2 = va_arg(args, A2*);
        -:  451:        A3 *a3 = va_arg(args, A3*);
        -:  452:        new(dest) ArgStruct(a1, a2, a3);
        -:  453:    }
        -:  454:    static void copy_constructor(void *dest , void* src) {
        -:  455:        ArgStruct *src_args = static_cast<ArgStruct *>(src);
        -:  456:        new(dest) ArgStruct(&(src_args->a1), &(src_args->a2), &(src_args->a3));
        -:  457:    }
        -:  458:    static void destructor(void *args) {
        -:  459:        ArgStruct *argstruct = static_cast<ArgStruct *>(args);
        -:  460:        argstruct->~arg_struct();
        -:  461:    }
        -:  462:*/
        -:  463:protected:
        -:  464:    static const struct FunctionPointerBase<R>::ArgOps _fp3_ops;
        -:  465:};
        -:  466:
        -:  467:template <typename R, typename A1, typename A2, typename A3>
        -:  468:const struct FunctionPointerBase<R>::ArgOps FunctionPointer3<R,A1,A2,A3>::_fp3_ops = {
        -:  469:    FunctionPointer3<R,A1,A2,A3>::constructor,
        -:  470:    FunctionPointer3<R,A1,A2,A3>::copy_constructor,
        -:  471:    FunctionPointer3<R,A1,A2,A3>::destructor
        -:  472:};
        -:  473:
        -:  474:/** A class for storing and calling a pointer to a static or member void function with four arguments
        -:  475: */
        -:  476:template <typename R, typename A1, typename A2, typename A3, typename A4>
        -:  477:class FunctionPointer4 : public FunctionPointerBase<R> {
        -:  478:protected:
        -:  479:    typedef struct arg_struct{
        -:  480:        A1 a1;
        -:  481:        A2 a2;
        -:  482:        A3 a3;
        -:  483:        A4 a4;
        -:  484:        arg_struct(const A1 *b1, const A2 *b2, const A3* b3, const A4* b4) {
        -:  485:            a1 = *b1;
        -:  486:            a2 = *b2;
        -:  487:            a3 = *b3;
        -:  488:            a4 = *b4;
        -:  489:        }
        -:  490:    } ArgStruct;
        -:  491:
        -:  492:public:
        -:  493:    typedef R(*static_fp)(A1, A2, A3, A4);
        -:  494:    /** Create a FunctionPointer, attaching a static function
        -:  495:     *
        -:  496:     *  @param function The void static function to attach (default is none)
        -:  497:     */
        -:  498:    FunctionPointer4(static_fp function = 0) {
        -:  499:        attach(function);
        -:  500:    }
        -:  501:
        -:  502:    /** Create a FunctionPointer, attaching a member function
        -:  503:     *
        -:  504:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:  505:     *  @param function The address of the void member function to attach
        -:  506:     */
        -:  507:    template<typename T>
        -:  508:    FunctionPointer4(T *object, R (T::*member)(A1, A2, A3, A4)) {
        -:  509:        attach(object, member);
        -:  510:    }
        -:  511:
        -:  512:    /** Attach a static function
        -:  513:     *
        -:  514:     *  @param function The void static function to attach (default is none)
        -:  515:     */
        -:  516:    void attach(static_fp function) {
        -:  517:        FunctionPointerBase<R>::_object = reinterpret_cast<void*>(function);
        -:  518:        FunctionPointerBase<R>::_membercaller = &FunctionPointer4::staticcaller;
        -:  519:    }
        -:  520:
        -:  521:    /** Attach a member function
        -:  522:     *
        -:  523:     *  @param object The object pointer to invoke the member function on (i.e. the this pointer)
        -:  524:     *  @param function The address of the void member function to attach
        -:  525:     */
        -:  526:    template<typename T>
        -:  527:    void attach(T *object, R (T::*member)(A1, A2, A3, A4))
        -:  528:    {
        -:  529:        FunctionPointerBase<R>::_object = static_cast<void*>(object);
        -:  530:        *reinterpret_cast<R (T::**)(A1, A2, A3, A4)>(FunctionPointerBase<R>::_member) = member;
        -:  531:        FunctionPointerBase<R>::_membercaller = &FunctionPointer4::membercaller<T>;
        -:  532:    }
        -:  533:
        -:  534:    FunctionPointerBind<R> bind(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4) {
        -:  535:        FunctionPointerBind<R> fp;
        -:  536:        fp.bind(&_fp4_ops, (ArgStruct *) NULL, this, &a1, &a2, &a3, &a4);
        -:  537:        return fp;
        -:  538:    }
        -:  539:
        -:  540:
        -:  541:    /** Call the attached static or member function
        -:  542:     */
        -:  543:    R call(A1 a1, A2 a2, A3 a3, A4 a4)
        -:  544:    {
        -:  545:        ArgStruct Args(&a1, &a2, &a3, &a4);
        -:  546:        return FunctionPointerBase<R>::call(&Args);
        -:  547:    }
        -:  548:
        -:  549:    static_fp get_function()const
        -:  550:    {
        -:  551:        return reinterpret_cast<static_fp>(FunctionPointerBase<R>::_object);
        -:  552:    }
        -:  553:
        -:  554:    R operator ()(A1 a1, A2 a2, A3 a3, A4 a4) {
        -:  555:        return call(a1, a2, a3, a4);
        -:  556:    }
        -:  557:
        -:  558:private:
        -:  559:    template<typename T>
        -:  560:    static R membercaller(void *object, uintptr_t *member, void *arg) {
        -:  561:        ArgStruct *Args = static_cast<ArgStruct *>(arg);
        -:  562:        T* o = static_cast<T*>(object);
        -:  563:        R (T::**m)(A1, A2, A3, A4) = reinterpret_cast<R (T::**)(A1, A2, A3, A4)>(member);
        -:  564:        return (o->**m)(Args->a1, Args->a2, Args->a3, Args->a4);
        -:  565:    }
        -:  566:    static R staticcaller(void *object, uintptr_t *member, void *arg) {
        -:  567:        ArgStruct *Args = static_cast<ArgStruct *>(arg);
        -:  568:        (void) member;
        -:  569:        static_fp f = reinterpret_cast<static_fp>(object);
        -:  570:        return f(Args->a1, Args->a2, Args->a3, Args->a4);
        -:  571:    }
        -:  572:/*    static void constructor(void * dest, va_list args) {
        -:  573:        A1 *a1 = va_arg(args, A1*);
        -:  574:        A2 *a2 = va_arg(args, A2*);
        -:  575:        A3 *a3 = va_arg(args, A3*);
        -:  576:        A4 *a4 = va_arg(args, A4*);
        -:  577:        new(dest) ArgStruct(a1, a2, a3, a4);
        -:  578:    }
        -:  579:    static void copy_constructor(void *dest , void* src) {
        -:  580:        ArgStruct *src_args = static_cast<ArgStruct *>(src);
        -:  581:        new(dest) ArgStruct(&(src_args->a1), &(src_args->a2), &(src_args->a3), &(src_args->a4));
        -:  582:    }
        -:  583:    static void destructor(void *args) {
        -:  584:        ArgStruct *argstruct = static_cast<ArgStruct *>(args);
        -:  585:        argstruct->~arg_struct();
        -:  586:    }
        -:  587:*/
        -:  588:protected:
        -:  589:    static const struct FunctionPointerBase<R>::ArgOps _fp4_ops;
        -:  590:};
        -:  591:
        -:  592:template <typename R, typename A1, typename A2, typename A3, typename A4>
        -:  593:const struct FunctionPointerBase<R>::ArgOps FunctionPointer4<R,A1,A2,A3,A4>::_fp4_ops = {
        -:  594:    FunctionPointer4<R,A1,A2,A3,A4>::constructor,
        -:  595:    FunctionPointer4<R,A1,A2,A3,A4>::copy_constructor,
        -:  596:    FunctionPointer4<R,A1,A2,A3,A4>::destructor
        -:  597:};
        -:  598:
        -:  599:typedef FunctionPointer0<void> FunctionPointer;
        -:  600://typedef FunctionPointer1<void, int> event_callback_t;
        -:  601:
        -:  602:} // namespace mbed
        -:  603:
        -:  604:#endif
